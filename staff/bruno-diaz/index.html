<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <title></title>
</head>
<body>
    <nav id="navList"></nav>

    <section id="contain">
        <h1>Variable</h1>
        <div class="contain__block">
            <div>
                
            </div>
            <pre class="language-javascript"><code>

            </code></pre>
        </div>

        <h1>Object</h1>
        <div class="contain__block">
            <div>
                
            </div>
            <pre class="language-javascript"><code>

            </code></pre>
        </div>

        <h1>Function</h1>
        <div class="contain__block">
            <div>
                Una funci贸n es un trozo o conjunto de funcionalidad que ejecutan una tarea (se aconseja que tenga una 煤nica responasibilidad).
            
                <h6>Declarar una funci贸n</h6>
                <pre class="language-javascript"><code>
function name() { ... }
                </code></pre>
                Donde vemos las siguientes partes:
                <ul class="contain__list">
                    <li>name -> ID para determinar la funci贸n</li>
                    <li>() -> operador de agrupaci贸n para recibir par谩metros</li>
                    <li>{} -> para delimitar el bloque de sentencias que definen la funci贸n</li>
                </ul>
                
                <h6> Invocaci贸n de una funci贸n</h6>
                <pre class="language-javascript"><code>
name()
                </code></pre>
                Con esto se puede determinar que console.log() o alert() son funciones.

                Una cualidad de JS es que la funci贸n se puede invocar antes de declararse --> ver Hoisting (alzado)

                Las funciones en JS se pueden utilizar en cualquier contexto: se pueden invocar, enviar, retornar, pasar como par谩metro, devolverlas para ejecutar m谩s adelante (callback),...

                Se recomienda que toda funci贸n debe de retornar algo y para ello tenemos el 'return'.
            </div>
            <pre class="language-javascript"><code>
function uppercase(text) {
    return text.toUpperCase()
}
uppercase("lorem ipsum dolor sit amet")
// "LOREM IPSUM DOLOR SIT AMET"
            </code></pre>
        </div>

        <h3 id="function__R">Return</h3>
        <div class="contain__block">
            <div>
                Una funci贸n hace una serie de tareas y al finalizar, por norma general, <strong>debe de retornar el resultado</strong> de dichas tareas; esto se consigue con el <strong>return</strong>.
                <br><br>
                Por ejemplo, una funci贸n que calcula el cuadrado de un n煤mero tendr谩 como entrada a ese n煤mero y como salida tendr谩 el valor resultante de hallar el cuadrado de ese n煤mero. Para ello, se utiliza la palabra <strong>return</strong> seguida del valor que se desea devolver.
                <br><br>
                Para almacenar un valor de devoluci贸n de una funci贸n, tenemos que asignar la llamada a esa funci贸n como contenido en una variable:
                <br>
                <pre class="language-javascript"><code>
var name = function()
                </code></pre>
            </div>
            <pre class="language-javascript"><code>
> Ejemplo con RETURN:
    function uppercase(text) {
        return text.toUpperCase()
    }
    var nombre = uppercase('Pepe')
    console.log(nombre)
    // 'PEPE'

> Ejemplo sin RETURN:
    function uppercase(text) {
        text.toUpperCase()
    }
    var nombre = uppercase('Pepe')
    console.log(nombre)
    // undefined
            </code></pre>
        </div>

        <h3 id="function__C">Closures</h3>
        <div class="contain__block">
            <div>
                A grandes rasgos, un closure es una funci贸n dentro de una funci贸n. De este modo, dicha funci贸n <i>inner</i> solo est谩 disponible dentro de la funci贸n <i>outer</i> y tiene acceso a sus variables/argumentos.
                <pre class="language-javascript"><code>
function suma(a) {
    return function(b) {
        return a + b
    }
}
console.log( suma(1)(2) )
//  3 
                </code></pre>
                Esta t茅cnica se utiliza com煤nmente para dar a los objetos la privacidad de los datos y en lenguajes que soportan first-class functions es muy recurrente para dar acceso a variables de un scope externo desde dentro de sus lambdas (funci贸n que se utiliza como dato).
            </div>
            <pre class="language-javascript"><code>
// Ejemplo donde la privacidad de los datos es importante
var user = ( function(id) {
    function getUserFromApi() {
        ... // Petici贸n AJAX
        return {
            id: 10,
            name: 'Eduardo',
            lastname: 'Rodr铆guez Pati帽o',
            email: 'erodriguezp105@gmail.com'
        }
    }
    var data =  getUserFromApi(id)
    return {
        data: data,
        sayHello: function() {
            return 'Hi, I am ' + data.name;
        }
    }
})(10)
console.log( user.sayHello() )
            </code></pre>
        </div>

        <h1 id="function__A">Scope</h1>
        <div class="contain__block">
            <div>
                El scope (o contexto de ejecuci贸n) es el alcance (visibilidad) que vamos a tener de una variable para poder utilizarla. Puede ser <strong>Global</strong> (se puede acceder desde cualquier parte de nuestro c贸digo) o <strong>Local</strong> (su acceso es limitado).
                <br><br>
                Dentro de las funciones podemos declarar variables y todas ellas tendr谩n validez durante la ejecuci贸n de la funci贸n, es decir, son variables locales; las variables declaradas fuera de funciones se denominan variables globales. 
                <br>
                <div class="moreInfo">
                    <i class="fa fa-arrow-circle-right "></i> Ver m谩s sobre <a href="#">Variables</a>
                </div>
                <br>
                Siempre que se declare una variable dentro de una funci贸n, inclusive si hubiera una funci贸n global con el mismo nombre, su comportamiento ser谩 local. En cambio, si no declaramos una variable en una funci贸n JS entender谩 que estamos haciendo referencia a una variable global a la p谩gina, de modo que si no est谩 creada la variable la crea, pero siempre como variable global.
                <div class="moreInfo">
                    <i class="fa fa-arrow-circle-right "></i> Ver m谩s sobre <a href="#">mbito de variables</a>
                </div>
            </div>
            <pre class="language-javascript"><code>
var a = 5
function foo() {
    console.log(a)     // undefined
    var a = 10
    var b = 40
    console.log(a)     // 10
    if (true) {
        console.log(a) // 10
        var a = 20
        console.log(a) // 20
        for( a=0; a<11; a++) {
            console.log(a)
        }
    }
    console.log(a)     // 11
}
console.log(a)         //  5
foo()
console.log(a)         //  5
console.log(b)         //  ReferenceError: local is not defined
            </code></pre>
        </div>

        <h3 id="">Hoisting</h3>
        <div class="contain__block">
            <div>
                En JS, la declaraci贸n de las variables y funciones son "movidas" o "elevadas" al comienzo del c贸digo, a este efecto se le denomina Hoisting. En realidad no se "mueven", son asignadas en memoria durante la fase de compilaci贸n y solo aplica a la declaraci贸n (no a su asignaci贸n).
            </div>
            <pre class="language-javascript"><code>
console.log(a)
var a = 1
// undefined

b = 10
console.log(b)
var b = 20
// 10

            </code></pre>
        </div>

        <h1>Eventos</h1>
        <div class="contain__block">
            <div>
                Los eventos son acciones que realiza el ususario (consciente o incosciente), a las que debemos anticiparnos y preparar la p谩gina o aplicaci贸n para que sepan c贸mo se debe de actuar ante ellos. Los eventos se definen de tres modos: por <strong>atributo HTML</strong> asociada a una funci贸n (<code>&lt;tag onclick=""&gt;</code>), a trav茅s de una <strong>propiedad JS</strong> asociada a una funci贸n (<code>tag.onclick = ...</code>) o con el <strong>m茅todo addEventListener</strong> donde a帽ades una funci贸n (<code>tag.addEventListener("click", ...)</code>)
            </div>
        </div>

        <h3>Evento - Atributos HTML</h3>
        <div class="contain__block">
            <div>
                Definimos un evento a trav茅s de un atributo HTML. Siempre comienzan por <code>on</code> y en el valor se indica la funci贸n que se quiere ejecutar.
            </div>
            <pre class="language-html"><code>
&lt;button onClick="sendMessage()"&gt; Press me!&lt;/button&gt;
&lt;script&gt;
  var sendMessage = () => alert("Hello!")
&lt;/script&gt;
            </code></pre>
        </div>

        <h3>Evento - Propiedad JS</h3>
        <div class="contain__block">
            <div>
                Se define haciendo uso de las propiedades de JS. Por cada evento, existe una propiedad (onclick, por ejemplo) disponible en el elemento en cuesti贸n.
            </div>
            <pre class="language-html"><code>
&lt;button&gt; Press me!&lt;/button&gt;
&lt;script&gt;
    var button = document.querySelector("button")
    button.onclick = () => alert("Hello!")
&lt;/script&gt;
            </code></pre>
        </div>

        <h3>Evento - addEventListener</h3>
        <div class="contain__block">
            <div>
                Con el m茅todo <code>.addEventListener()</code> a帽adimos una funci贸n que escucha el evento y, si ocurre, la ejecuta. Este m茅todo permite una forma m谩s c贸moda y program谩tica de a帽adir eventos, sin sobreescribir las funciones definidas anteriormente. Su m茅todo contrapartida es <code>.removeEventListener()</code>, el cual elimina esa funci贸n que escucha el evento.
            </div>
            <pre class="language-javascript"><code>
var btn = document.getElementById("myBtn")
btn.addEventListener("click", function(){
    var div = document.getElementById("div")
    div.innerHTML = "Hello World"
})
            </code></pre>
        </div>

        <h1>Patrones de dise帽o</h1>
        <div class="contain__block">
            <div>
                
            </div>
        </div>

        <h3 id="function__FE">Function Expression</h3>
        <div class="contain__block">
            <div>
                Una Expresi贸n Funcional se realiza con una funci贸n (an贸nima o no) pero asignada a una variable:
                <br><br>
                En este caso no se puede invocar la funci贸n antes de declararla, pues al alzar la declaraci贸n de la variable esta tiene valor undefined:
                <br><br>
                Otra diferencia importante de estas respecto las funciones declarativas es que las primeras cargan al ser invocadas mientras que las segundas lo hacen al cargar el programa.
            </div>
            <pre class="language-javascript"><code>
name()
var name = function() { ... }
// 'TypeError: name is not a function' --> name = undefined

name()
function name() {
    console.log('Lorem ipsum...')
}
// "Lorem ipsum...""
            </code></pre>
        </div>

        <h3 id="function__IIFE">Immediately Invoked Function Expression - IIFE</h3>
        <div class="contain__block">
            <div>
                Es un patr贸n de dise帽o, tambi茅n conocido como <strong>funci贸n autoejecutable</strong>, que se compone de dos partes: una funci贸n an贸nima con alcance l茅xico encerrado por el operador de agrupaci贸n () y una funci贸n cuya ejecuci贸n es inmediata.
                <pre class="language-javascript"><code>
( function() {...} )()
                </code></pre>
                Como su nombre indica, es una expresi贸n de funci贸n que es ejecutada inmediatamente, autoejecutable. El operador de agrupaci贸n () impide accesar variables fuera de 茅l y no se ensucia el scope global. Da pie a los muy usados patrones de dise帽o Revealing Module Pattern.
            </div>
            <pre class="language-javascript"><code>
var result = (function() {
    var name = 'Barry';
    return name;
})()
result // "Barry"
            </code></pre>
        </div>
        
        <h3 id="function__HOF">Higher Order Function - HOF</h3>
        <div class="contain__block">
            <div>
                Abstracci贸n caracter铆stica de los lenguajes de <strong>Programaci贸n Funcional</strong> se trata a las funciones como 'first-class citizens': las funciones son objetos que pueden ser tratados como variables, par谩metros o como valores de retorno de otras funciones.
            </div>
            <pre class="language-javascript"><code>
function diHola() { return "Hola " }
function saludar(saludo, nombre) {
    console.log(saludo() + nombre)
}
saludar(diHola, "JavaScript!")   // "Hola JavaScripr!"
            </code></pre>
        </div>

        <h1 id="paradigma">Paradigmas de programaci贸n</h1>
        <div class="contain__block">
            <div>
                Un paradigma de programaci贸n es el estilo de construir la estructura y los elementos de un programa. Los m谩s famosos son el <strong>Declarativo</strong> y el <strong>Imperativo</strong>.
            </div>
        </div>

        <h3 id="paradigma__DI">Programaci贸n Declarativa vs. Imperativa</h3>
        <div class="contain__block">
            <div>
                El <strong>paradigma declarativo</strong> construye un c贸digo en un lenguaje especificando qu茅 quiere hacer sin importar el c贸mo. Su opuesto ser铆a el <strong>paradigma imperativo</strong>. En el primero ser铆a como pedirle a la computadora que te prepare una taza de t茅 (sin importar c贸mo lo haga, lo importante es obtener una taza de t茅), mientras que en el segundo le ir铆as pasando los comandos para conseguirlo, describes el c贸mo obtenerlo: ve a la cocina > si hay una tetera ac茅rcate a ella > si no tiene suficiente agua la rellenas hasta que haya suficiente agua para una taza de t茅 > una vez tenga suficiente agua la pones a calentar > ...
                <pre class="language-javascript"><code>
SELECT * FROM clientes<br>
&lt;div&gt;&lt;/div&gt;
                </code></pre>
                En los ejemplos anteriores no se est谩 implementando el SELECT o el div, simplemente le est谩s diciendo a la computadora qu茅 hacer omitiendo el c贸mo; te centras en los pasos que hay que hacer y no en c贸mo hacerlos. De este modo eliminamos c贸digo repetitivo que no aporta valor al producto, dejando as铆 un c贸digo m谩s legible, menos propenso al error, con un comportamiento predecible y resultar谩 sencilla combinarlo con test unitarios.
            </div>
        </div>

        <h3 id="paradigma__F">Programaci贸n Funcional</h3>
        <div class="contain__block">
            <div>
                La Programaci贸n Funcional es un sub-paradigma de la Programaci贸n Declarativa que fue teorizada en 1930 e implementada en los a帽os 60. Se puede explicar siguiendo dos reglas en tu c贸digo:
                <ul class="contain__list">
                    <li>Uso de <strong>funciones puras y aisladas</strong>.</li>
                    <li>Evita la <strong>mutabilidad y efectos secundarios</strong>.</li>
                </ul>
            </div>
        </div>

        <h6>Funciones Puras y Aisladas</h6>
        <div class="contain__block">
            <div>
                Aquellas funciones que operan utilizando solo los par谩metros de entrada sin recurrir a ning煤n otro elemento fuera de ellas, es decir, son funciones idempotentes (<em>dado unos par谩metros de entrada de id茅ntico valor, la funci贸n siempre devolver谩 el mismo resultado</em>) y sin efectos secundarios (<em>el c贸mputo de la funci贸n, su l贸gica, no implica efecto observable colateral fuera de ella</em>).
                <br><br>
                Por un lado, podemos observar que siempre que llames a esta funci贸n con los mismo par谩metros, su resultado ser谩 id茅ntico; no requiere o depende de ning煤n estado o valor fuera de ella. Por otro, el c谩lculo que realiza nuestra funci贸n no modifica durante el mismo nada fuera de ella: ni a ni b son mutadas durante el proceso.
                <br><br>
                Los beneficios de las funciones puras son: inmutabilidad (no modificamos nada fuera de nuestra funci贸n; nos limitamos a un 煤nico e identificable scope), son f谩ciles de testear, comportamiento legible y predecible (autodocumentaci贸n), paralelizaci贸n (debido a la ausencia de dependencias y a que ning煤n otro componente principal se ver谩 afectado), memoization (optimizaci贸n del c贸digo guardando el resultado de funciones recurrentes en cache).
            </div>
            <pre class="language-javascript"><code>
// Funci贸n Pura
function pure(a, b) {
    return a + b
}
// Funciones NO Puras
Math.random()
new Date().toLocaleTimeString()

function getFirstElementInArray(arr) {
    return arr.splice(0,1) // Splice modifica el arr de entrada
}
            </code></pre>
        </div>

        <h6>Mutabilidad y Efectos Secundarios</h6>
        <div class="contain__block">
            <div>
                Se trata de limitar los cambios de variables y, en caso de necesitarlo, realizarlo en copias. 驴C贸mo nos aseguramos de esto? Primero, haciendo uso de los argumentos de la funci贸n y de ning煤n objeto o variable global. Segundo, asegur谩ndonos de no modificar ninguna variable u objeto: crearemos nuevas variables/objetos y las devolveremos (si es necesario) desde una funci贸n.
                <br><br>
                Los beneficios de esta filosof铆a son conseguir un c贸digo referencialmente transparente (las llamadas a funciones se pueden reemplazar por los valores que representan sin afectar al resultado).
            </div>
            <pre class="language-javascript"><code>
const obj = Object.freeze({
    noCambia: 'Locked' }) // La funci贸n "freeze" aplica la inmutabilidad.

obj.noCambia = 0
delete obj.noCambia
obj.agregarProp = true
obj
// { noCambia: "Locked" }
            </code></pre>
        </div>

        <h6>Otras caracter铆sticas</h6>
        <div class="contain__block">
            <div>
                <strong>Recursi贸n</strong>: funciones que se llaman a s铆 mismas. Puede correr el riesgo de bloquear el navegador si no se hace bien, pero nos permite dejar de mutar las variables del estado.
                <br><br>
                <strong>Currying</strong>: proceso de descomponer una funci贸n que toma m谩s de un par谩metro en una serie de funciones que se invocan con los mismos argumentos, pero de manera parcial. Es muy 煤til cuando necesitas reutilizar la misma funci贸n varias veces y los argumentos cambian.
                <br><br>
                <strong>Aplicaci贸n parcial</strong>: ver bind
                <!-- https://www.freecodecamp.org/espanol/news/que-es-la-programacion-funcional-una-guia-de-javascript-para-principiantes/ -->
                <br><br>
                <strong>Composici贸n</strong>: tomar funciones peque帽as y agruparlas/combinarlas para generar funciones m谩s grandes. De este modo, estructuramos el c贸digo a partir de funciones reutilizables.
            </div>
            <pre class="language-javascript"><code>
// RECURSIN
function sum(num){
    if (num === 0) {
        return 0;
    } else {
        return num + sum(--num)
    }
}
sum(4)    // 10

// CURRYING
function suma(primerNum){
    return function(segundoNum){
            return primerNum + segundoNum;
    }
}
let suma10 = suma(10)
suma10(2);   // 12
let suma20 = suma(20)
suma20(2);   // 22

// COMPOSICIN
function suma10(num) {
	return num + 10;
}
function suma100(num) {
    return num + 100;
}
// Podemos componer estas dos a lo siguiente:
function compuesta(num){
	return suma10(suma100(num));
}
compuesta(1)   // 111
            </code></pre>
        </div>

        <h1>Web component</h1>
        <div class="contain__block">
            <div>
                En un contexto web, cuando hablamos de <strong>componente</strong> nos referimos a una forma de unir el marcado (HTML), estilo (CSS) y funcionalidad (JS) con una misma finalidad. Por ende, los web components son un paquete de diferentes tecnolog铆as que te permiten crear elementos personalizados reutilizables, con su funcionalidad encapsulada y apartada del resto del c贸digo para evitar colisiones. Consta de diferentes tecnolog铆as y tenemos la posibilidad de combinarlas para crear potentes componentes web. Las principales son: <strong>custom elements</strong>, <strong>shadow DOM</strong> y <strong>HTML templates</strong>.
            </div>
        </div>

        <h6>Custom Elements</h6>
        <div class="contain__block">
            <div>
                Conjunto de APIs de JS que permiten asociar etiquetas propias de HTML a la clase definida para tu componente. Las dota de su propia funcionalidad, marcado HTML o estilo CSS y se implementa desde JS, extendiendo de la clase HTMLElement.
            </div>
            <pre class="language-html"><code>
// Etiqueta div est谩ndar de HTML5
&lt;div class="emoji"&gt; :) &lt;/div&gt;
// class AppEmoji extends HTMLElement { ... }
// window.customElements.define('app-emoji', AppEmoji)
&lt;app-emoji name="happy"&gt; :) &lt;/app-emoji&gt;
            </code></pre>
        </div>

        <h6>HTML Templates</h6>
        <div class="contain__block">
            <div>
                Se trata de unas etiquetas HTML, <code>&lt;template&gt;</code> y <code>&lt;slot&gt;</code>, que nos permite crear contenido inerte en una p谩gina, es decir, el navegador no invertir谩 recursos en su procesamiento hasta que lo utilicemos desde JS para crear nuevos elementos en base a 茅l.
            </div>
            <pre class="language-html"><code>
&lt;template id="user-template"&gt;
    &lt;h1&gt;Username&lt;/h1&gt;
    &lt;img src="user-image.png" alt="Username"&gt;
    &lt;a href="https://website.com/"&gt;URL&lt;/a&gt;
&lt;/template&gt;
            </code></pre>
        </div>

        <h6>Shadow DOM</h6>
        <div class="contain__block">
            <div>
                El <strong>DOM</strong> es la estructura de elementos de un documento HTML. La API <strong>shadow DOM</strong> pretende crear una estructura aislada, independiente del DOM principal, donde se pueda trabajar de forma local sin que repercuta con el resto del documento. Es renderizado por separado del documento DOM principal, de esta forma, se pueden mantener caracter铆sticas de un elemento en privado y as铆 puede tener estilos y scripts sin miedo a colisiones con otras partes del documento.
            </div>
            <pre class="language-html"><code>
&lt;div class="element"&gt;
    #shadow-root
        &lt;div class="inner-element"&gt;
            ...
        &lt;/div&gt;
&lt;/div&gt;
            </code></pre>
        </div>

        <h6>Otras tecnolog铆as</h6>
        <div class="contain__block">
            <div>
                <ul class="contain__list">
                    <li>
                        <strong>M贸dulos ECMAScript</strong> (ESM o ESModules): est谩ndar de JS que permite organizar elementos de nuestro c贸digo JS (const, funciones, clases, etc) en m贸dulos y exportarlos para ponerlos a disposici贸n en otro archivo JS que quiera importartlos.
                    </li>
                    <li>
                        <strong>CSS Scopes & Shadow Parts</strong>: con la llegada de los web component hubieron novedades tambi茅n en el mundo del CSS con la llegada de pseudoclases CSS que nos permiten aplicar estilos al elemento contenedor (<code>:host</code>, <code>:host()</code> y <code>:host-context()</code>), de un pseudoelemento CSS (<code>:slotted()</code>) y una especificaci贸n que nos provee de un pseudoelemento denominada <strong>CSS Shadow Parts</strong> (<code>::part()</code>)
                    </li>
                </ul>
            </div>
            <pre class="language-html"><code>
// ESM o ESModules
&lt;script type="module" src="fichero.js"&gt;&lt;/script&gt;
            </code></pre>
        </div>

        <h3>Creaci贸n del Web Component</h3>
        <div class="contain__block">
            <div>
                Como hemos visto anteriormente, debemos empezar a crear nuestro web component con  el custom element.





                Toda etiqueta HTML tiene una serie de <strong>atributos</strong> que lo pueden acompa帽ar (<code>class</code>, <code>id</code>, <code>name</code>,...), pero en los web components desempe帽an un papel important铆simo, ya que pueden existir atributos para pasar informaci贸n a la l贸gica del componente.

                ...
            </div>
            <pre class="language-html"><code>
            </code></pre>
        </div>

        <h3>Eventos Web Component</h3>
        <div class="contain__block">
            <div>
                Los eventos son acciones que realiza el ususario (consciente o incosciente), a las que debemos anticiparnos y preparar la p谩gina o aplicaci贸n para que sepan c贸mo se debe de actuar ante ellos. Pero, 驴cu谩l es la manera m谩s apropiadas de poner un evento en un web component?
                <div class="moreInfo">
                    <i class="fa fa-arrow-circle-right "></i> Ver m谩s sobre <a href="#">Eventos</a>
                </div>
            </div>
        </div>

        <h6>handleEvent</h6>
        <div class="contain__block">
            <div>
                El uso de los sistemas de eventos vistos en cap铆tulos anteriores (atributos HTML, porpiedades JS y addEventListener) nos generar谩 problemas en nuestro web component, ya sea por ser necesario que la funci贸n a ejecutar est茅 en un contexto global o porque el c贸digo resultante sea cr铆ptico y escasamente legible. Para solucionarlo existe un patr贸n en JS muy interesante que permite organizar el c贸digo de nuestra clase de una forma muy elegante. Se trata de crear un m茅todo llamado <code>.handleEvent()</code> que se encargar谩 de gestionar los eventos y reenviarlos a donde corresponda.
                <br><br>
                En el segundo par谩metro del m茅todo <code>.addEventListener()</code> colocamos <code>this</code> (una referencia a la clase). De este modo, el navegador buscar谩 si existe un m茅todo llamado <code>.hableEvent()</code> y si existe, lo procesa. En dicho m茅todo lo que hacemos es comprobar el <code>event.type</code> (tipo de evento que se ha lanzado: click, mousedown, mousemove, etc.) y ejecutar la funci贸n que buscamos. De esta forma, centralizamos en este m茅todo la gesti贸n de las funciones necesarias, por lo que nos quedar谩 todo m谩s legible y organizado.
            </div>
            <pre class="language-html"><code>
&lt;app-element&gt;&lt;/app-element&gt;

&lt;script&gt;
    customElements.define("app-element", class extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: "open" });
        }

        handleEvent(event) {
            if (event.type === "click")
                this.sendMessage();
        }

        sendMessage() {
            alert("Hello!");
        }

        connectedCallback() {
            this.shadowRoot.innerHTML = "&lt;button&gt; Press me!&lt;/button&gt;";
            this.button = this.shadowRoot.querySelector("button");
            this.button.addEventListener("click", this);
        }

        disconnectedCallback() {
            this.button.removeEventListener("click", this);
        }
    });
&lt;/script&gt;
            </code></pre>
        </div>

        <h6>Custom Events</h6>
        <div class="contain__block">
            <div>
                Custom Events es un mecanismo que nos permite crear nuestros eventos personalizados propios y utilizarlos en momentos concretos de nuestro c贸digo para disparar funciones asociadas al igual que se hace con los eventos habituales en el JS, como <code>click</code> o <code>input</code>, por ejemplo. Adem谩s, en Web Components se emplean para comunicar entre componentes y hacerlo de una forma en la que mantengamos la l贸gica (sin acoplar c贸digo a componentes ajenos o generar dependencias externas).
            </div>
        </div>

        <strong>Sintaxis</strong>
        <div class="contain__block">
            <div>
                Crear un custom event es muy sencillo. Se basa en crear una instancia del objeto <code>CustomEvent</code>, al cual le pasaremos un <code>string</code> con el nombre que le hemos puesto a nuestro evento, y un segundo par谩metro que ser谩 un <code>object</code> de opciones. En vez de <code>CustomEvent</code> tambi茅n se puede usar <code>Event</code> si es que no queremos a帽adir datos personalizados.
            </div>
            <pre class="language-javascript"><code>
const nameEvent = new CustomEvent("nameEvent", options);
const nameEvent = new Event("nameEvent");
            </code></pre>
        </div>

        <strong>Opciones customizables</strong>
        <div class="contain__block">
            <div>
                El segundo par谩metro de <code>CustomEvent</code> es donde podemos especificar varios detalles en relaci贸n al comportamiento o contenido del evento:
                <ul class="contain__list">
                    <li><strong>detail</strong> <i>[object - false]</i>: objeto que contiene toda la informaci贸n que queremos transmitir.</li>
                    <li><strong>bubbles</strong> <i>[bool - false]</i>: indica si el evento debe burbujear en el DOM "hacia la superficie" o no.</li>
                    <li><strong>composed</strong> <i>[bool - false]</i>: indica si la propagaci贸n puede atravesar el Shadow DOM o no.</li>
                    <li><strong>cancelable</strong> <i>[bool - false]</i>: indica si el comportamiento se puede cancelar con <code>.preventDefault()</code> o no.</li>
                </ul>
                <pre class="language-javascript"><code>

                </code></pre>
            </div>
            <pre class="language-javascript"><code>
const MessageEvent = new CustomEvent("message", {
    detail: {
        from: "Manz",
        message: "Hello!"
    },
    bubbles: true,
    composed: true
});
            </code></pre>
        </div>

        <strong>Propagaci贸n de eventos - bubbles</strong>
        <div class="contain__block">
            <div>
                
            </div>
        </div>

        <strong>Recepci贸n de eventos - capture</strong>
        <div class="contain__block">
            <div>
                
            </div>
        </div>

        <strong>Atravesar Shadow - composed</strong>
        <div class="contain__block">
            <div>
                
            </div>
        </div>

        

        




        
    </section>

    <script>
        $(function(){
            $("#navList").load("./navList.html");
        });
    </script>
    <script src="js/prism.js"></script>
</body>
</html>