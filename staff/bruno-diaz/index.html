<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <title></title>
</head>
<body>
    <nav id="navList"></nav>

    <section id="contain">
        <h1>Variable</h1>
        <div class="contain__block">
            <div>
                
            </div>
            <pre class="language-javascript"><code>

            </code></pre>
        </div>

        <h1>Object</h1>
        <div class="contain__block">
            <div>
                
            </div>
            <pre class="language-javascript"><code>

            </code></pre>
        </div>

        <h1>Function</h1>
        <div class="contain__block">
            <div>
                Una funci√≥n es un trozo o conjunto de funcionalidad que ejecutan una tarea (se aconseja que tenga una √∫nica responasibilidad).
            
                <h6>Declarar una funci√≥n</h6>
                <pre class="language-javascript"><code>
function name() { ... }
                </code></pre>
                Donde vemos las siguientes partes:
                <ul class="contain__list">
                    <li>name -> ID para determinar la funci√≥n</li>
                    <li>() -> operador de agrupaci√≥n para recibir par√°metros</li>
                    <li>{} -> para delimitar el bloque de sentencias que definen la funci√≥n</li>
                </ul>
                
                <h6> Invocaci√≥n de una funci√≥n</h6>
                <pre class="language-javascript"><code>
name()
                </code></pre>
                Con esto se puede determinar que console.log() o alert() son funciones.

                Una cualidad de JS es que la funci√≥n se puede invocar antes de declararse --> ver Hoisting (alzado)

                Las funciones en JS se pueden utilizar en cualquier contexto: se pueden invocar, enviar, retornar, pasar como par√°metro, devolverlas para ejecutar m√°s adelante (callback),...

                Se recomienda que toda funci√≥n debe de retornar algo y para ello tenemos el 'return'.
            </div>
            <pre class="language-javascript"><code>
function uppercase(text) {
    return text.toUpperCase()
}
uppercase("lorem ipsum dolor sit amet")
// "LOREM IPSUM DOLOR SIT AMET"
            </code></pre>
        </div>

        <h3 id="function__R">Return</h3>
        <div class="contain__block">
            <div>
                Una funci√≥n hace una serie de tareas y al finalizar, por norma general, <strong>debe de retornar el resultado</strong> de dichas tareas; esto se consigue con el <strong>return</strong>.
                <br><br>
                Por ejemplo, una funci√≥n que calcula el cuadrado de un n√∫mero tendr√° como entrada a ese n√∫mero y como salida tendr√° el valor resultante de hallar el cuadrado de ese n√∫mero. Para ello, se utiliza la palabra <strong>return</strong> seguida del valor que se desea devolver.
                <br><br>
                Para almacenar un valor de devoluci√≥n de una funci√≥n, tenemos que asignar la llamada a esa funci√≥n como contenido en una variable:
                <br>
                <pre class="language-javascript"><code>
var name = function()
                </code></pre>
            </div>
            <pre class="language-javascript"><code>
> Ejemplo con RETURN:
    function uppercase(text) {
        return text.toUpperCase()
    }
    var nombre = uppercase('Pepe')
    console.log(nombre)
    // 'PEPE'

> Ejemplo sin RETURN:
    function uppercase(text) {
        text.toUpperCase()
    }
    var nombre = uppercase('Pepe')
    console.log(nombre)
    // undefined
            </code></pre>
        </div>

        <h3 id="function__C">Closures</h3>
        <div class="contain__block">
            <div>
                A grandes rasgos, un closure es una funci√≥n dentro de una funci√≥n. De este modo, dicha funci√≥n <i>inner</i> solo est√° disponible dentro de la funci√≥n <i>outer</i> y tiene acceso a sus variables/argumentos.
                <pre class="language-javascript"><code>
function suma(a) {
    return function(b) {
        return a + b
    }
}
console.log( suma(1)(2) )
//  3 
                </code></pre>
                Esta t√©cnica se utiliza com√∫nmente para dar a los objetos la privacidad de los datos y en lenguajes que soportan first-class functions es muy recurrente para dar acceso a variables de un scope externo desde dentro de sus lambdas (funci√≥n que se utiliza como dato).
            </div>
            <pre class="language-javascript"><code>
// Ejemplo donde la privacidad de los datos es importante
var user = ( function(id) {
    function getUserFromApi() {
        ... // Petici√≥n AJAX
        return {
            id: 10,
            name: 'Eduardo',
            lastname: 'Rodr√≠guez Pati√±o',
            email: 'erodriguezp105@gmail.com'
        }
    }
    var data =  getUserFromApi(id)
    return {
        data: data,
        sayHello: function() {
            return 'Hi, I am ' + data.name;
        }
    }
})(10)
console.log( user.sayHello() )
            </code></pre>
        </div>

        <h3 id="function__C">Call - Apply - Bind</h3>
        <div class="contain__block">
            <div>
                <h6>Las funciones son instancias de Object</h6>
                En JS, salvo los primitivos, null y undefined, todo son objetos que poseen m√©todos y propiedades. Esto quiere decir que las funciones son instancias de la clase Function y que esta, a su vez, es una instancia de la clase Object. Por lo tanto, una funci√≥n es un objeto con propiedades y m√©todos.
                <br><br>
                En este ejemplo podemos apreciar que las funciones tienen una propiedad llamada name que devuelve el nombre del funci√≥n, en este caso ¬´nuevaFuncion¬ª y un m√©todo (los m√©todos no dejan de ser funciones que declaramos en un objeto para operar con ellos) que nos devuelve en un string todo el c√≥digo de la funci√≥n.
            </div>
            <pre class="language-javascript"><code>
var nuevaFuncion = function(arg1, arg2) {
    console.log("Mis argumentos son " + arg1 + " y " + arg2);
}
console.log(nuevaFuncion.name); 
// nuevaFuncion
console.log(nuevaFuncion.toString()); 
// c√≥digo de la funci√≥n
            </code></pre>
        </div>
        <div class="contain__block">
            <div>
                <h6>This</h6>
                Los m√©todos call, apply y bind en Javascript sirven para llamar a una funci√≥n asignando un valor a ‚Äòthis‚Äô, aprende como se usan y en que se diferencian.
                <br><br>
                Para entender qu√© hacen antes tenemos que saber qu√© es ‚Äòthis‚Äô y cu√°ndo se incluye. This es una variable que hace referencia al contexto de la funci√≥n, es la manera de acceder a nuestra propia instancia. Notad que hablamos del contexto de la funci√≥n, pero a lo que se accede es a la instancia, y adem√°s la instancia que usamos para llamar la funci√≥n, se ve claro con un ejemplo, mira atentamente el c√≥digo de ejemplo.
                <br><br>
                persona.saludar() devuelve ¬´Hola Javi!¬ª pues this.nombre no hace referencia a la variable que est√° en el interior de la funci√≥n sino a la instancia desde donde se llama a ‚Äòpersona‚Äô; si te est√°s preguntando por qu√© digo que es una instancia y no un objeto es porque todos los objetos son instancias de Object. otraPersona.saludar() devuelve ¬´Hola √ìscar!¬ª, porque como acabamos de decir this accede a la instancia que usamos para llamar a la funci√≥n y en este caso es otraPersona, simplemente mira lo que hay antes del √∫ltimo punto, esa es siempre la instancia que llama. De manera que el m√©todo saludar en este segundo caso est√° declarado en la instancia ‚Äòpersona‚Äô, pero es llamado desde la instancia ‚ÄòotraPersona‚Äô y por eso el this apunta a esta.
                <br><br>
                Como antes deciamos call, apply y bind sirven para invocar funciones o m√©todos especificando el valor que tiene ‚Äòthis‚Äô.
            </div>
            <pre class="language-javascript"><code>
var persona = {
    nombre: "Javi",
    saludar: function() {
        var nombre = "Julio"
        console.log("Hola " + this.nombre + "!")
    }
}
persona.saludar() // Hola Javi!

var otraPersona = {
    nombre: "√ìscar",
    saludar: persona.saludar // referencia al m√©todo de persona
}

otraPersona.saludar() // Hola √ìscar!
            </code></pre>
        </div>
        <div class="contain__block">
            <div>
                <h6>Call()</h6>
                El m√©todo call() llama a una funci√≥n con un valor dado this y con argumentos provistos individualmente. Permite que una funci√≥n/m√©todo que pertenece a un objeto, sea asignada y llamada por otro objeto diferente, asign√°ndole un nuevo valor de this. De este modo, puedes escribir un m√©todo una vez y heredarlo otro objeto, sin tener que reescribir el m√©todo en el nuevo objeto.
                <h6>Apply()</h6>
                El m√©todo apply() invoca una determinada funci√≥n asignando expl√≠citamente el objeto this y un array (o similar) como par√°metros para dicha funci√≥n. Aunque la sintaxis de esta funci√≥n es casi id√©ntica a call(), la diferencia fundamental es que call() acepta una lista de argumentos, mientras que apply() acepta un simple array con los argumentos.
                <h6>Bind()</h6>
                La funci√≥n bind() crea una nueva funci√≥n (funci√≥n ligada con el mismo cuerpo) que ser√° llamada (la funci√≥n objetivo de la funci√≥n ligada) con la referencia this asociada al primer argumento de bind(), el cual no podr√° ser sobreescrito. Tambi√©n acepta par√°metros predeterminados que anteceder√°n al resto de los par√°metros espec√≠ficos cuando la funci√≥n objetivo sea llamada. Una funci√≥n ligada tambi√©n puede ser constru√≠da utilizando el operador new: al hacerlo, actuar√° como si en su lugar hubiera sido constru√≠da la funci√≥n objetivo.
                <br><br>
                El m√©todo bind() crea una nueva funci√≥n, que cuando es llamada, asigna a su operador this el valor entregado, con una secuencia de argumentos dados precediendo a cualquiera entregados cuando la funci√≥n es llamada. El valor de this es ignorado cuando la funci√≥n es llamada con el operador new.
            </div>
            <pre class="language-javascript"><code>
// Objetos de partida
var persona = {
    nombre: "Arturo",
    saludar: function(saludo, dia) {
        var nombre = "Bruno";
        console.log(saludo + this.nombre + ", feliz " + dia + "!");
    }
}
var otraPersona = {
    nombre: "Carlos",
}

// M√©todo CALL()
persona.saludar.call(otraPersona, "Buenos d√≠as ", "lunes")
// Buenos d√≠as Carlos, feliz lunes!

// M√©todo APPLY()
persona.saludar.apply(otraPersona, ["Hola ", "martes"])
// Hola Carlos, feliz martes!

// M√©todo BIND()
var copia = persona.saludar.bind(otraPersona, "Hi ", "mi√©rcoles")
copia()
// Hi Carlos, feliz mi√©rcoles!
otraPersona.nombre = "David"
copia()
// Hi David, feliz mi√©rcoles!
            </code></pre>
        </div><a href="http://www.oscarlijo.com/blog/call-apply-y-bind-en-javascript/#about" target="_blank">M√°s info</a>

        <h1 id="function__A">Scope</h1>
        <div class="contain__block">
            <div>
                El scope (o contexto de ejecuci√≥n) es el alcance (visibilidad) que vamos a tener de una variable para poder utilizarla. Puede ser <strong>Global</strong> (se puede acceder desde cualquier parte de nuestro c√≥digo) o <strong>Local</strong> (su acceso es limitado).
                <br><br>
                Dentro de las funciones podemos declarar variables y todas ellas tendr√°n validez durante la ejecuci√≥n de la funci√≥n, es decir, son variables locales; las variables declaradas fuera de funciones se denominan variables globales. 
                <br>
                <div class="moreInfo">
                    <i class="fa fa-arrow-circle-right "></i> Ver m√°s sobre <a href="#">Variables</a>
                </div>
                <br>
                Siempre que se declare una variable dentro de una funci√≥n, inclusive si hubiera una funci√≥n global con el mismo nombre, su comportamiento ser√° local. En cambio, si no declaramos una variable en una funci√≥n JS entender√° que estamos haciendo referencia a una variable global a la p√°gina, de modo que si no est√° creada la variable la crea, pero siempre como variable global.
                <div class="moreInfo">
                    <i class="fa fa-arrow-circle-right "></i> Ver m√°s sobre <a href="#">√Åmbito de variables</a>
                </div>
            </div>
            <pre class="language-javascript"><code>
var a = 5
function foo() {
    console.log(a)     // undefined
    var a = 10
    var b = 40
    console.log(a)     // 10
    if (true) {
        console.log(a) // 10
        var a = 20
        console.log(a) // 20
        for( a=0; a<11; a++) {
            console.log(a)
        }
    }
    console.log(a)     // 11
}
console.log(a)         //  5
foo()
console.log(a)         //  5
console.log(b)         //  ReferenceError: local is not defined
            </code></pre>
        </div>

        <h3 id="">Hoisting</h3>
        <div class="contain__block">
            <div>
                En JS, la declaraci√≥n de las variables y funciones son "movidas" o "elevadas" al comienzo del c√≥digo, a este efecto se le denomina Hoisting. En realidad no se "mueven", son asignadas en memoria durante la fase de compilaci√≥n y solo aplica a la declaraci√≥n (no a su asignaci√≥n).
            </div>
            <pre class="language-javascript"><code>
console.log(a)
var a = 1
// undefined

b = 10
console.log(b)
var b = 20
// 10

            </code></pre>
        </div>

        <h1>Eventos</h1>
        <div class="contain__block">
            <div>
                Los eventos son acciones que realiza el ususario (consciente o incosciente), a las que debemos anticiparnos y preparar la p√°gina o aplicaci√≥n para que sepan c√≥mo se debe de actuar ante ellos. Los eventos se definen de tres modos: por <strong>atributo HTML</strong> asociada a una funci√≥n (<code>&lt;tag onclick=""&gt;</code>), a trav√©s de una <strong>propiedad JS</strong> asociada a una funci√≥n (<code>tag.onclick = ...</code>) o con el <strong>m√©todo addEventListener</strong> donde a√±ades una funci√≥n (<code>tag.addEventListener("click", ...)</code>)
            </div>
        </div>

        <h3>Evento - Atributos HTML</h3>
        <div class="contain__block">
            <div>
                Definimos un evento a trav√©s de un atributo HTML. Siempre comienzan por <code>on</code> y en el valor se indica la funci√≥n que se quiere ejecutar.
            </div>
            <pre class="language-html"><code>
&lt;button onClick="sendMessage()"&gt;üëÄ Press me!&lt;/button&gt;
&lt;script&gt;
  var sendMessage = () => alert("Hello!")
&lt;/script&gt;
            </code></pre>
        </div>

        <h3>Evento - Propiedad JS</h3>
        <div class="contain__block">
            <div>
                Se define haciendo uso de las propiedades de JS. Por cada evento, existe una propiedad (onclick, por ejemplo) disponible en el elemento en cuesti√≥n.
            </div>
            <pre class="language-html"><code>
&lt;button&gt;üëÄ Press me!&lt;/button&gt;
&lt;script&gt;
    var button = document.querySelector("button")
    button.onclick = () => alert("Hello!")
&lt;/script&gt;
            </code></pre>
        </div>

        <h3>Evento - addEventListener</h3>
        <div class="contain__block">
            <div>
                Con el m√©todo <code>.addEventListener()</code> a√±adimos una funci√≥n que escucha el evento y, si ocurre, la ejecuta. Este m√©todo permite una forma m√°s c√≥moda y program√°tica de a√±adir eventos, sin sobreescribir las funciones definidas anteriormente. Su m√©todo contrapartida es <code>.removeEventListener()</code>, el cual elimina esa funci√≥n que escucha el evento.
            </div>
            <pre class="language-javascript"><code>
var btn = document.getElementById("myBtn")
btn.addEventListener("click", function(){
    var div = document.getElementById("div")
    div.innerHTML = "Hello World"
})
            </code></pre>
        </div>

        <h1>Patrones de dise√±o</h1>
        <div class="contain__block">
            <div>
                
            </div>
        </div>

        <h3 id="function__FE">Function Expression</h3>
        <div class="contain__block">
            <div>
                Una Expresi√≥n Funcional se realiza con una funci√≥n (an√≥nima o no) pero asignada a una variable:
                <br><br>
                En este caso no se puede invocar la funci√≥n antes de declararla, pues al alzar la declaraci√≥n de la variable esta tiene valor undefined:
                <br><br>
                Otra diferencia importante de estas respecto las funciones declarativas es que las primeras cargan al ser invocadas mientras que las segundas lo hacen al cargar el programa.
            </div>
            <pre class="language-javascript"><code>
name()
var name = function() { ... }
// 'TypeError: name is not a function' --> name = undefined

name()
function name() {
    console.log('Lorem ipsum...')
}
// "Lorem ipsum...""
            </code></pre>
        </div>

        <h3 id="function__IIFE">Immediately Invoked Function Expression - IIFE</h3>
        <div class="contain__block">
            <div>
                Es un patr√≥n de dise√±o, tambi√©n conocido como <strong>funci√≥n autoejecutable</strong>, que se compone de dos partes: una funci√≥n an√≥nima con alcance l√©xico encerrado por el operador de agrupaci√≥n () y una funci√≥n cuya ejecuci√≥n es inmediata.
                <pre class="language-javascript"><code>
( function() {...} )()
                </code></pre>
                Como su nombre indica, es una expresi√≥n de funci√≥n que es ejecutada inmediatamente, autoejecutable. El operador de agrupaci√≥n () impide accesar variables fuera de √©l y no se ensucia el scope global. Da pie a los muy usados patrones de dise√±o Revealing Module Pattern.
            </div>
            <pre class="language-javascript"><code>
var result = (function() {
    var name = 'Barry';
    return name;
})()
result // "Barry"
            </code></pre>
        </div>
        
        <h3 id="function__HOF">Higher Order Function - HOF</h3>
        <div class="contain__block">
            <div>
                Abstracci√≥n caracter√≠stica de los lenguajes de <strong>Programaci√≥n Funcional</strong> se trata a las funciones como 'first-class citizens': las funciones son objetos que pueden ser tratados como variables, par√°metros o como valores de retorno de otras funciones.
            </div>
            <pre class="language-javascript"><code>
function diHola() { return "Hola " }
function saludar(saludo, nombre) {
    console.log(saludo() + nombre)
}
saludar(diHola, "JavaScript!")   // "Hola JavaScripr!"
            </code></pre>
        </div>

        <h1 id="paradigma">Paradigmas de programaci√≥n</h1>
        <div class="contain__block">
            <div>
                Un paradigma de programaci√≥n es el estilo de construir la estructura y los elementos de un programa. Los m√°s famosos son el <strong>Declarativo</strong> y el <strong>Imperativo</strong>.
            </div>
        </div>

        <h3 id="paradigma__DI">Programaci√≥n Declarativa vs. Imperativa</h3>
        <div class="contain__block">
            <div>
                El <strong>paradigma declarativo</strong> construye un c√≥digo en un lenguaje especificando qu√© quiere hacer sin importar el c√≥mo. Su opuesto ser√≠a el <strong>paradigma imperativo</strong>. En el primero ser√≠a como pedirle a la computadora que te prepare una taza de t√© (sin importar c√≥mo lo haga, lo importante es obtener una taza de t√©), mientras que en el segundo le ir√≠as pasando los comandos para conseguirlo, describes el c√≥mo obtenerlo: ve a la cocina > si hay una tetera ac√©rcate a ella > si no tiene suficiente agua la rellenas hasta que haya suficiente agua para una taza de t√© > una vez tenga suficiente agua la pones a calentar > ...
                <pre class="language-javascript"><code>
SELECT * FROM clientes<br>
&lt;div&gt;&lt;/div&gt;
                </code></pre>
                En los ejemplos anteriores no se est√° implementando el SELECT o el div, simplemente le est√°s diciendo a la computadora qu√© hacer omitiendo el c√≥mo; te centras en los pasos que hay que hacer y no en c√≥mo hacerlos. De este modo eliminamos c√≥digo repetitivo que no aporta valor al producto, dejando as√≠ un c√≥digo m√°s legible, menos propenso al error, con un comportamiento predecible y resultar√° sencilla combinarlo con test unitarios.
            </div>
        </div>

        <h3 id="paradigma__F">Programaci√≥n Funcional</h3>
        <div class="contain__block">
            <div>
                La Programaci√≥n Funcional es un sub-paradigma de la Programaci√≥n Declarativa que fue teorizada en 1930 e implementada en los a√±os 60. Se puede explicar siguiendo dos reglas en tu c√≥digo:
                <ul class="contain__list">
                    <li>Uso de <strong>funciones puras y aisladas</strong>.</li>
                    <li>Evita la <strong>mutabilidad y efectos secundarios</strong>.</li>
                </ul>
            </div>
        </div>

        <h6>Funciones Puras y Aisladas</h6>
        <div class="contain__block">
            <div>
                Aquellas funciones que operan utilizando solo los par√°metros de entrada sin recurrir a ning√∫n otro elemento fuera de ellas, es decir, son funciones idempotentes (<em>dado unos par√°metros de entrada de id√©ntico valor, la funci√≥n siempre devolver√° el mismo resultado</em>) y sin efectos secundarios (<em>el c√≥mputo de la funci√≥n, su l√≥gica, no implica efecto observable colateral fuera de ella</em>).
                <br><br>
                Por un lado, podemos observar que siempre que llames a esta funci√≥n con los mismo par√°metros, su resultado ser√° id√©ntico; no requiere o depende de ning√∫n estado o valor fuera de ella. Por otro, el c√°lculo que realiza nuestra funci√≥n no modifica durante el mismo nada fuera de ella: ni a ni b son mutadas durante el proceso.
                <br><br>
                Los beneficios de las funciones puras son: inmutabilidad (no modificamos nada fuera de nuestra funci√≥n; nos limitamos a un √∫nico e identificable scope), son f√°ciles de testear, comportamiento legible y predecible (autodocumentaci√≥n), paralelizaci√≥n (debido a la ausencia de dependencias y a que ning√∫n otro componente principal se ver√° afectado), memoization (optimizaci√≥n del c√≥digo guardando el resultado de funciones recurrentes en cache).
            </div>
            <pre class="language-javascript"><code>
// Funci√≥n Pura
function pure(a, b) {
    return a + b
}
// Funciones NO Puras
Math.random()
new Date().toLocaleTimeString()

function getFirstElementInArray(arr) {
    return arr.splice(0,1) // Splice modifica el arr de entrada
}
            </code></pre>
        </div>

        <h6>Mutabilidad y Efectos Secundarios</h6>
        <div class="contain__block">
            <div>
                Se trata de limitar los cambios de variables y, en caso de necesitarlo, realizarlo en copias. ¬øC√≥mo nos aseguramos de esto? Primero, haciendo uso de los argumentos de la funci√≥n y de ning√∫n objeto o variable global. Segundo, asegur√°ndonos de no modificar ninguna variable u objeto: crearemos nuevas variables/objetos y las devolveremos (si es necesario) desde una funci√≥n.
                <br><br>
                Los beneficios de esta filosof√≠a son conseguir un c√≥digo referencialmente transparente (las llamadas a funciones se pueden reemplazar por los valores que representan sin afectar al resultado).
            </div>
            <pre class="language-javascript"><code>
const obj = Object.freeze({
    noCambia: 'Locked' }) // La funci√≥n "freeze" aplica la inmutabilidad.

obj.noCambia = 0
delete obj.noCambia
obj.agregarProp = true
obj
// { noCambia: "Locked" }
            </code></pre>
        </div>

        <h6>Otras caracter√≠sticas</h6>
        <div class="contain__block">
            <div>
                <strong>Recursi√≥n</strong>: funciones que se llaman a s√≠ mismas. Puede correr el riesgo de bloquear el navegador si no se hace bien, pero nos permite dejar de mutar las variables del estado.
                <br><br>
                <strong>Currying</strong>: proceso de descomponer una funci√≥n que toma m√°s de un par√°metro en una serie de funciones que se invocan con los mismos argumentos, pero de manera parcial. Es muy √∫til cuando necesitas reutilizar la misma funci√≥n varias veces y los argumentos cambian.
                <br><br>
                <strong>Aplicaci√≥n parcial</strong>: ver bind
                <!-- https://www.freecodecamp.org/espanol/news/que-es-la-programacion-funcional-una-guia-de-javascript-para-principiantes/ -->
                <br><br>
                <strong>Composici√≥n</strong>: tomar funciones peque√±as y agruparlas/combinarlas para generar funciones m√°s grandes. De este modo, estructuramos el c√≥digo a partir de funciones reutilizables.
            </div>
            <pre class="language-javascript"><code>
// RECURSI√ìN
function sum(num){
    if (num === 0) {
        return 0;
    } else {
        return num + sum(--num)
    }
}
sum(4)    // 10

// CURRYING
function suma(primerNum){
    return function(segundoNum){
            return primerNum + segundoNum;
    }
}
let suma10 = suma(10)
suma10(2);   // 12
let suma20 = suma(20)
suma20(2);   // 22

// COMPOSICI√ìN
function suma10(num) {
	return num + 10;
}
function suma100(num) {
    return num + 100;
}
// Podemos componer estas dos a lo siguiente:
function compuesta(num){
	return suma10(suma100(num));
}
compuesta(1)   // 111
            </code></pre>
        </div>

        <h1>Web component</h1>
        <div class="contain__block">
            <div>
                En un contexto web, cuando hablamos de <strong>componente</strong> nos referimos a una forma de unir el marcado (HTML), estilo (CSS) y funcionalidad (JS) con una misma finalidad. Por ende, los web components son un paquete de diferentes tecnolog√≠as que te permiten crear elementos personalizados reutilizables, con su funcionalidad encapsulada y apartada del resto del c√≥digo para evitar colisiones. Consta de diferentes tecnolog√≠as y tenemos la posibilidad de combinarlas para crear potentes componentes web. Las principales son: <strong>custom elements</strong>, <strong>shadow DOM</strong> y <strong>HTML templates</strong>.
            </div>
        </div>

        <h6>Custom Elements</h6>
        <div class="contain__block">
            <div>
                Conjunto de APIs de JS que permiten asociar etiquetas propias de HTML a la clase definida para tu componente. Las dota de su propia funcionalidad, marcado HTML o estilo CSS y se implementa desde JS, extendiendo de la clase HTMLElement.
            </div>
            <pre class="language-html"><code>
// Etiqueta div est√°ndar de HTML5
&lt;div class="emoji"&gt; :) &lt;/div&gt;
// class AppEmoji extends HTMLElement { ... }
// window.customElements.define('app-emoji', AppEmoji)
&lt;app-emoji name="happy"&gt; :) &lt;/app-emoji&gt;
            </code></pre>
        </div>

        <h6>HTML Templates</h6>
        <div class="contain__block">
            <div>
                Se trata de unas etiquetas HTML, <code>&lt;template&gt;</code> y <code>&lt;slot&gt;</code>, que nos permite crear contenido inerte en una p√°gina, es decir, el navegador no invertir√° recursos en su procesamiento hasta que lo utilicemos desde JS para crear nuevos elementos en base a √©l.
            </div>
            <pre class="language-html"><code>
&lt;template id="user-template"&gt;
    &lt;h1&gt;Username&lt;/h1&gt;
    &lt;img src="user-image.png" alt="Username"&gt;
    &lt;a href="https://website.com/"&gt;URL&lt;/a&gt;
&lt;/template&gt;
            </code></pre>
        </div>

        <h6>Shadow DOM</h6>
        <div class="contain__block">
            <div>
                El <strong>DOM</strong> es la estructura de elementos de un documento HTML. La API <strong>shadow DOM</strong> pretende crear una estructura aislada, independiente del DOM principal, donde se pueda trabajar de forma local sin que repercuta con el resto del documento. Es renderizado por separado del documento DOM principal, de esta forma, se pueden mantener caracter√≠sticas de un elemento en privado y as√≠ puede tener estilos y scripts sin miedo a colisiones con otras partes del documento.
            </div>
            <pre class="language-html"><code>
&lt;div class="element"&gt;
    #shadow-root
        &lt;div class="inner-element"&gt;
            ...
        &lt;/div&gt;
&lt;/div&gt;
            </code></pre>
        </div>

        <h6>Otras tecnolog√≠as</h6>
        <div class="contain__block">
            <div>
                <ul class="contain__list">
                    <li>
                        <strong>M√≥dulos ECMAScript</strong> (ESM o ESModules): est√°ndar de JS que permite organizar elementos de nuestro c√≥digo JS (const, funciones, clases, etc) en m√≥dulos y exportarlos para ponerlos a disposici√≥n en otro archivo JS que quiera importartlos.
                    </li>
                    <li>
                        <strong>CSS Scopes & Shadow Parts</strong>: con la llegada de los web component hubieron novedades tambi√©n en el mundo del CSS con la llegada de pseudoclases CSS que nos permiten aplicar estilos al elemento contenedor (<code>:host</code>, <code>:host()</code> y <code>:host-context()</code>), de un pseudoelemento CSS (<code>:slotted()</code>) y una especificaci√≥n que nos provee de un pseudoelemento denominada <strong>CSS Shadow Parts</strong> (<code>::part()</code>)
                    </li>
                </ul>
            </div>
            <pre class="language-html"><code>
// ESM o ESModules
&lt;script type="module" src="fichero.js"&gt;&lt;/script&gt;
            </code></pre>
        </div>

        <h3>Creaci√≥n del Web Component</h3>
        <div class="contain__block">
            <div>
                Como hemos visto anteriormente, debemos empezar a crear nuestro web component con  el custom element.





                Toda etiqueta HTML tiene una serie de <strong>atributos</strong> que lo pueden acompa√±ar (<code>class</code>, <code>id</code>, <code>name</code>,...), pero en los web components desempe√±an un papel important√≠simo, ya que pueden existir atributos para pasar informaci√≥n a la l√≥gica del componente.

                ...
            </div>
            <pre class="language-html"><code>
            </code></pre>
        </div>

        <h3>Eventos Web Component</h3>
        <div class="contain__block">
            <div>
                Los eventos son acciones que realiza el ususario (consciente o incosciente), a las que debemos anticiparnos y preparar la p√°gina o aplicaci√≥n para que sepan c√≥mo se debe de actuar ante ellos. Pero, ¬øcu√°l es la manera m√°s apropiadas de poner un evento en un web component?
                <div class="moreInfo">
                    <i class="fa fa-arrow-circle-right "></i> Ver m√°s sobre <a href="#">Eventos</a>
                </div>
            </div>
        </div>

        <h6>handleEvent</h6>
        <div class="contain__block">
            <div>
                El uso de los sistemas de eventos vistos en cap√≠tulos anteriores (atributos HTML, porpiedades JS y addEventListener) nos generar√° problemas en nuestro web component, ya sea por ser necesario que la funci√≥n a ejecutar est√© en un contexto global o porque el c√≥digo resultante sea cr√≠ptico y escasamente legible. Para solucionarlo existe un patr√≥n en JS muy interesante que permite organizar el c√≥digo de nuestra clase de una forma muy elegante. Se trata de crear un m√©todo llamado <code>.handleEvent()</code> que se encargar√° de gestionar los eventos y reenviarlos a donde corresponda.
                <br><br>
                En el segundo par√°metro del m√©todo <code>.addEventListener()</code> colocamos <code>this</code> (una referencia a la clase). De este modo, el navegador buscar√° si existe un m√©todo llamado <code>.hableEvent()</code> y si existe, lo procesa. En dicho m√©todo lo que hacemos es comprobar el <code>event.type</code> (tipo de evento que se ha lanzado: click, mousedown, mousemove, etc.) y ejecutar la funci√≥n que buscamos. De esta forma, centralizamos en este m√©todo la gesti√≥n de las funciones necesarias, por lo que nos quedar√° todo m√°s legible y organizado.
            </div>
            <pre class="language-html"><code>
&lt;app-element&gt;&lt;/app-element&gt;

&lt;script&gt;
    customElements.define("app-element", class extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: "open" });
        }

        handleEvent(event) {
            if (event.type === "click")
                this.sendMessage();
        }

        sendMessage() {
            alert("Hello!");
        }

        connectedCallback() {
            this.shadowRoot.innerHTML = "&lt;button&gt;üëÄ Press me!&lt;/button&gt;";
            this.button = this.shadowRoot.querySelector("button");
            this.button.addEventListener("click", this);
        }

        disconnectedCallback() {
            this.button.removeEventListener("click", this);
        }
    });
&lt;/script&gt;
            </code></pre>
        </div>

        <h6>Custom Events</h6>
        <div class="contain__block">
            <div>
                Custom Events es un mecanismo que nos permite crear nuestros eventos personalizados propios y utilizarlos en momentos concretos de nuestro c√≥digo para disparar funciones asociadas al igual que se hace con los eventos habituales en el JS, como <code>click</code> o <code>input</code>, por ejemplo. Adem√°s, en Web Components se emplean para comunicar entre componentes y hacerlo de una forma en la que mantengamos la l√≥gica (sin acoplar c√≥digo a componentes ajenos o generar dependencias externas).
            </div>
        </div>

        <strong>Sintaxis</strong>
        <div class="contain__block">
            <div>
                Crear un custom event es muy sencillo. Se basa en crear una instancia del objeto <code>CustomEvent</code>, al cual le pasaremos un <code>string</code> con el nombre que le hemos puesto a nuestro evento, y un segundo par√°metro que ser√° un <code>object</code> de opciones. En vez de <code>CustomEvent</code> tambi√©n se puede usar <code>Event</code> si es que no queremos a√±adir datos personalizados.
            </div>
            <pre class="language-javascript"><code>
const nameEvent = new CustomEvent("nameEvent", options);
const nameEvent = new Event("nameEvent");
            </code></pre>
        </div>

        <strong>Opciones customizables</strong>
        <div class="contain__block">
            <div>
                El segundo par√°metro de <code>CustomEvent</code> es donde podemos especificar varios detalles en relaci√≥n al comportamiento o contenido del evento:
                <ul class="contain__list">
                    <li><strong>detail</strong> <i>[object - false]</i>: objeto que contiene toda la informaci√≥n que queremos transmitir.</li>
                    <li><strong>bubbles</strong> <i>[bool - false]</i>: indica si el evento debe burbujear en el DOM "hacia la superficie" o no.</li>
                    <li><strong>composed</strong> <i>[bool - false]</i>: indica si la propagaci√≥n puede atravesar el Shadow DOM o no.</li>
                    <li><strong>cancelable</strong> <i>[bool - false]</i>: indica si el comportamiento se puede cancelar con <code>.preventDefault()</code> o no.</li>
                </ul>
                <pre class="language-javascript"><code>

                </code></pre>
            </div>
            <pre class="language-javascript"><code>
const MessageEvent = new CustomEvent("message", {
    detail: {
        from: "Manz",
        message: "Hello!"
    },
    bubbles: true,
    composed: true
});
            </code></pre>
        </div>

        <strong>Propagaci√≥n de eventos - bubbles</strong>
        <div class="contain__block">
            <div>
                
            </div>
        </div>

        <strong>Recepci√≥n de eventos - capture</strong>
        <div class="contain__block">
            <div>
                
            </div>
        </div>

        <strong>Atravesar Shadow - composed</strong>
        <div class="contain__block">
            <div>
                
            </div>
        </div>

        

        




        
    </section>

    <script>
        $(function(){
            $("#navList").load("./navList.html");
        });
    </script>
    <script src="js/prism.js"></script>
</body>
</html>